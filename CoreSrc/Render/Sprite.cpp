//------------------------------------------------------------------------------//// Nutmeg::Core::Engine//// copyright:	(c) 2008-2011 One More Studio// author:		Alexey Egorov (FadeToBlack aka EvilSpirit)// url:			http://nutmeg-engine.ru// mail:		anandamide@mail.ru// icq:			455-761-951// skype:		fade_to_evil////------------------------------------------------------------------------------#include "Sprite.h"//------------------------------------------------------------------------------
#include "Debug.h"
//------------------------------------------------------------------------------//// namespace Nutmeg////------------------------------------------------------------------------------namespace Nutmeg {	//--------------------------------------------------------------------------	//	// class Sprite::Image	//	//--------------------------------------------------------------------------	Sprite::Image::Image() {		width_frames = 1;		height_frames = 1;	}	//--------------------------------------------------------------------------	//	// class Sprite::Imposter	//	//--------------------------------------------------------------------------	Sprite::Imposter::Imposter() {		image = -1;		start = 0;		end = 0;	}	//--------------------------------------------------------------------------	//	// class Sprite::Animation	//	//--------------------------------------------------------------------------	Sprite::Animation::Animation() {		speed = 30.0f;		yaw_count = 1;		pitch_count = 1;	}	//--------------------------------------------------------------------------	//	// class Sprite	//	//--------------------------------------------------------------------------	Sprite::Sprite() {	}	//--------------------------------------------------------------------------	Sprite::~Sprite() {	}	//--------------------------------------------------------------------------	// animations	//--------------------------------------------------------------------------	int Sprite::getAnimationsCount() const {		return animations.count();	}	//--------------------------------------------------------------------------	Sprite::Animation &Sprite::getAnimation(int index) {		return animations[index].getValue();	}	//--------------------------------------------------------------------------	const Sprite::Animation &Sprite::getAnimation(int index) const {		return animations[index].getValue();	}	//--------------------------------------------------------------------------	Sprite::Animation *Sprite::getAnimation(const char *id) {		return animations.get(id);	}	//--------------------------------------------------------------------------	const Sprite::Animation *Sprite::getAnimation(const char *id) const {		return animations.get(id);	}	//--------------------------------------------------------------------------	// images	//--------------------------------------------------------------------------	int Sprite::getImagessCount() const {		return images.count();	}	//--------------------------------------------------------------------------	Sprite::Image &Sprite::getImage(int index) {		return images[index].getValue();	}	//--------------------------------------------------------------------------	const Sprite::Image &Sprite::getImage(int index) const {		return images[index].getValue();	}	//--------------------------------------------------------------------------	Sprite::Image *Sprite::getImage(const char *id) {		return images.get(id);	}	//--------------------------------------------------------------------------	const Sprite::Image *Sprite::getImage(const char *id) const {		return images.get(id);	}	//--------------------------------------------------------------------------	//	//--------------------------------------------------------------------------	const char *Sprite::getName() const{		return name.str();	}	//--------------------------------------------------------------------------	void Sprite::readXml(const Xml *xml) {		// clear		images.clear();		animations.clear();		name = "";		xml->getArg("name", name);		//--------------------------------------------------		// read images		//--------------------------------------------------		const Xml *parent = xml->getChild("images");		if (parent == NULL) {			fatal("Sprite::readXml(): can not find \"images\" xml node.");			return;		}		for (int i=0; i<parent->getChildrenCount(); i++) {			const Xml *child = parent->getChild(i);			if (Str(child->getName()) != "image") {				//warning("Sprite::readXml(): unrecognized xml node \"%s\"", child->getName());				continue;			}			Sprite::Image *image = new Sprite::Image();			Str name;			Str file;			child->getArg("name", name);			child->getArg("file", file);			child->getArg("width_frames", image->width_frames);			child->getArg("height_frames", image->height_frames);			child->getArg("anchor", image->anchor);			image->texture.load(file);			images.append(new Str(name), image);		}		//--------------------------------------------------		// read animations		//--------------------------------------------------		parent = xml->getChild("animations");		if (parent == NULL) {			//console.echo("Sprite::readXml(): can not find \"animations\" xml node.");			fatal("Sprite::readXml(): can not find \"animations\" xml node.");			return;		}		for (int i=0; i<parent->getChildrenCount(); i++) {			const Xml *child = parent->getChild(i);			if (Str(child->getName()) != "animation") {				//console.echo("Sprite::readXml(): unrecognized xml node \"%s\"", child->getName());				warning("Sprite::readXml(): unrecognized xml node \"%s\"", child->getName());				continue;			}			Sprite::Animation *animation = new Sprite::Animation();			child->getArg("name", animation->name);			child->getArg("speed", animation->speed);			child->getArg("yaw_count", animation->yaw_count);			child->getArg("pitch_count", animation->pitch_count);			// allocate impostors			for (int j=0; j<animation->yaw_count; j++) {				Array <Imposter> *imposter_array = new Array <Imposter> ();				for (int k=0; k<animation->pitch_count; k++) {					imposter_array->append(new Imposter());				}				animation->imposters.append(imposter_array);			}			// load impostors			for (int j=0; j<child->getChildrenCount(); j++) {				const Xml *sub_child = child->getChild(j);				if (Str(sub_child->getName()) != "impostor") {					//console.echo("Sprite::readXml(): unrecognized xml node \"%s\"", child->getName());					warning("Sprite::readXml(): unrecognized xml node \"%s\"", child->getName());					continue;				}				int yaw;				int pitch;				Str image_id;				sub_child->getArg("yaw", yaw);				sub_child->getArg("pitch", pitch);				if (yaw < 0 || yaw >= animation->yaw_count) {					//console.echo("Sprite::readXml(): impostor yaw is out of ranage (yaw=%d, yaw_count = %d).", yaw, animation->yaw_count);					warning("Sprite::readXml(): impostor yaw is out of ranage (yaw=%d, yaw_count = %d).", yaw, animation->yaw_count);					continue;				}				if (pitch < 0 || pitch >= animation->pitch_count) {					//console.echo("Sprite::readXml(): impostor pitch is out of ranage (pitch=%d, pitch_count = %d).", pitch, animation->pitch_count);					warning("Sprite::readXml(): impostor pitch is out of ranage (pitch=%d, pitch_count = %d).", pitch, animation->pitch_count);					continue;				}				Imposter *impostor = &animation->imposters[yaw][pitch];				sub_child->getArg("image", image_id);				sub_child->getArg("start", impostor->start);				sub_child->getArg("end", impostor->end);				Image *image = images.get(image_id);				if (image != NULL) {					impostor->image = images.seek(image);				}			}			for (int j=0; j<animation->yaw_count; j++) {				for (int k=0; k<animation->pitch_count; k++) {					Imposter *imposter = &animation->imposters[i][k];					if (imposter->image < 0) {						//console.echo("Sprite::readXml(): impostor image is not exist (yaw=%d, pitch=%d)", j, k);						warning("Sprite::readXml(): impostor image is not exist (yaw=%d, pitch=%d)", j, k);					}				}			}			animations.append(new Str(animation->name), animation);		}	}	//--------------------------------------------------------------------------	// resource	//--------------------------------------------------------------------------	void Sprite::load(const char *name) {		Xml xml("sprite");		xml.load(name);		readXml(&xml);	}
	//--------------------------------------------------------------------------
	Sprite *Sprite::loadResource(const char *name) {
		Sprite *sprite = new Sprite();
		sprite->load(name);
		return sprite;
	}
	//--------------------------------------------------------------------------	bool Sprite::isExternal() const {		return true;	}	//--------------------------------------------------------------------------	//	// class SpriteState	//	//--------------------------------------------------------------------------	SpriteState::SpriteState() {		init();	}	//--------------------------------------------------------------------------	void SpriteState::init() {		current_animation = NULL;		frame_phase = 0.0f;		speed = 1.0f;		if (sprite->getAnimationsCount() > 0) {			current_animation = &sprite->getAnimation(0);		}	}	//--------------------------------------------------------------------------	void SpriteState::load(const char *name) {		sprite.load(name);		init();	}	//--------------------------------------------------------------------------	const char *SpriteState::getFileName() const {		return sprite.getName();	}	//--------------------------------------------------------------------------	int SpriteState::getYawIndex(float yaw) const {		int yaw_count = current_animation->yaw_count;		return int(floor(yaw / 2.0f / PI * float(yaw_count) + 0.5f)) % yaw_count;	}	//--------------------------------------------------------------------------	int SpriteState::getPitchIndex(float pitch) const {		int pitch_count = current_animation->pitch_count;		return int(floor(pitch / 2.0f / PI * float(pitch_count) + 0.5f)) % pitch_count;;	}	//--------------------------------------------------------------------------	const Sprite::Imposter *SpriteState::getImposter(float yaw, float pitch) const {		if (current_animation == NULL) return NULL;		int yaw_index = getYawIndex(yaw);		int pitch_index = getPitchIndex(pitch);		return &current_animation->imposters[yaw_index][pitch_index];	}	//--------------------------------------------------------------------------	const Sprite::Image *SpriteState::getImage(float yaw, float pitch) const {		if (current_animation == NULL) return NULL;		const Sprite::Imposter *imposter = getImposter(yaw, pitch);		if (imposter->image < 0) return NULL;		return &sprite->getImage(imposter->image);	}	//--------------------------------------------------------------------------	int SpriteState::getAtlasIndex(float yaw, float pitch) const {		if (current_animation == 0) return 0;		const Sprite::Imposter *imposter = getImposter(yaw, pitch);		int frames_count = imposter->end - imposter->start;		return imposter->start + int(floor(float(frames_count) * frame_phase)) % (frames_count);	}	//--------------------------------------------------------------------------	int SpriteState::getNextAtlasIndex(float yaw, float pitch) const {		if (current_animation == 0) return 0;		const Sprite::Imposter *imposter = getImposter(yaw, pitch);		int frames_count = imposter->end - imposter->start;		return imposter->start + int(floor(float(frames_count) * frame_phase) + 1) % frames_count;	}	//--------------------------------------------------------------------------	float SpriteState::getFramePhase(float yaw, float pitch) const {		if (current_animation == 0) return 0;		const Sprite::Imposter *imposter = getImposter(yaw, pitch);		float cur_frame = float(imposter->end - imposter->start) * frame_phase;		return cur_frame - floor(cur_frame);	}	//--------------------------------------------------------------------------	void SpriteState::setAnimation(const char *id, float speed_) {

		const Sprite::Animation *new_animation = sprite->getAnimation(id);

		speed = speed_;
		if (current_animation == new_animation) return;
		current_animation = new_animation;
	}	//--------------------------------------------------------------------------	void SpriteState::update(float dt) {		if (current_animation == NULL) return;		frame_phase += dt * speed * current_animation->speed;		frame_phase -= floor(frame_phase);	}	//--------------------------------------------------------------------------	void SpriteState::writeXml(Xml *xml) const {		if (sprite.is()) sprite.writeXml("sprite", xml);	}	//--------------------------------------------------------------------------	void SpriteState::readXml(const Xml *xml) {		sprite.readXml("sprite", xml);		init();	}	//--------------------------------------------------------------------------}//------------------------------------------------------------------------------